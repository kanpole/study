#+TITLE: Make学习笔记
#+OPTIONS: ^:{}

* make的基本规则

** 基本语法
#+BEGIN_SRC 
  目标名:依赖的目标或者文件名
  {TAB} 要执行的命令
  一个命令占一行
  .PHONY:clean #<-------声明伪目标
  clean:
  -rm ************

#有一个特殊模式,当前文件未找到的所有目标去另一个文件中找
%:force
  @$(MAKE) -f MakeFile $@
force:;
#+END_SRC

** 变量
+ *MAKEFILE* 可以指定包含的文件,在执行时优先于所有文件执行,其中的目标不会作为最终目标,类似与include行为,但是include包含进来的可以作为最终目标
+ *MAKEFILE_LIST* makefile文件链,可以用来标记当前正在执行的makefile文件
+ *VARIABLES* 不能赋值的全局变量列表
+ *VPATH* 依赖文件在当前目录不存在时,就去此变量指定的目录下搜索,这个变量指定的是makefile中的所有文件搜索路径包括依赖文件和目标文件,此变量用空格或冒号隔开,对所有文件都有效,需要更高级搜索路径设置方法,请使用关键字vpath
+ *GPATH* 一般情况下,make会在工作目录重建目标,通过此变量指定的目录,其下的所有目标都将在相应的目录下重建,也就是不会改变通过搜索与拼接得到的文件的完整路径名,前提是目标在GPATH指定路径中存在,否则还是会在工作目录创建
+ *.LIBPATTERNS* 添加库依赖 "-Iname";默认值为 lib%.so lib%.a;用来指定使用库作为依赖项,会按照一般的搜索方式外加,系统默认的库路径进行加载
+ *CURDIR* 此变量代表了make的当前工作路径,如果make 使用-C 进入一个目录后,此变量将被重新赋值,也可以手动赋值
+ *SHELL* 可以手动赋值,代表执行命令行的程序
+ *MAKE* 代表make程序,即使,make程序加了一些不执行动作的参数时,如果使用此变量代替make那么当前命令行也会被执行,同时,主make的命令参数会通过变量MAKEFLAGS传递给子make
+ *MAKEFLAGS* 存有上一个make的命令参数,以及变量的定义
+ *MAKELEVEL* 代表当前的调用深度,从0开始
+ *MAKEOVRRIDES* 命令行中的变量定义部分是赋值的它,MAKEFLAGS的变量定义部分其实引用的它,可以在makefile中来显式赋空来取消变量的传递
   为了与posix2.o兼容,如果出现.POSIX特殊目标时,修改此变量不会造成任何实质性修改
+ *MFLAGS* 老版本make中的命令行参数传递,只包含参数选项部分,不包含变量定义部分,而且参数选项以-开头
  使用时必须明确指定:
  #+BEGIN_SRC 
  all:
  cd subdir && $(MAKE) $(MFLAGS)
  #+END_SRC
+ *MAKECMDGOALS* 记录了命令行指定的那些终极目标

** 自动化变量
+ *$^* 表示所有搜索到的依赖文件(包含完整的路径名)
+ *$@* 表示目标名
  - $(@D) 代表目标文件的目录部分
  - $(@F) 代表目标文件的处目标以外的部分

+ *$<* 依赖文件列表中的第一个文件
+ *$* 在模式规则中,视为目标的"茎"部分,如果目标是一个带目录的,那么就包括前面目录的部分;如果存在文件dir/one
  #+BEGIN_SRC 
  dir/o%e
      echo $* 
  #+END_SRC
  此时$*代表 dir/n
  如果非模式规则中使用了此自动变量,并且后辍是make可识别的,那么它就代表后辍以外的部分,否则为空
+ *$%* 代表静态库目标;libx(a.o) 中的a.o
+ *%?* 所有比目标文件更新的依赖文件列表,以空格分割
+ *$^* 代表所有依赖文件,会去重
+ *$+* 与上面相同 但会保留重复依赖
+ *其他所有的自动化变量也可以添加D,F分别表示目录部分和文件部分
+ 如果想在依赖列表中使用自动化变量,有三个可以,$$@,$$(@D),$$(@F),他们是延迟展开的,而且只能用在目标明确文件的前提下

** 关键字
+ vpath环境设置关键字,三种用法,例:
  1) vpath %.h src:../headers    为匹配的模式,设置搜索路径
  2) vpath %.h                   取消指定模式的搜索路径设置
  3) vpath                       清除所有模式的搜索路径设置
+ export和unexport 加在变量定义前,可以传递/取消传递给子make,如果他们引用其他变量,那么会被立即展开
+ define fun .....endef定义命令包   使用时可以@$(fun)这样就不会回显命令
  - define定义的命令包可以作为eval函数的参数使用,它定义的命令包是一个用;分割的完整命令
  - 它定义的变量和=定义的变量都是延迟展开的,对其他变量的引用都是在使用时才会展开
  - 如果其中包含以tab开头的行时,此行会被作为命令行
** 特殊目标
+ .PHONY 该目标所有的依赖无论文件是否存在,该依赖目标下的命令都会被执行
+ .SUFFIXES :待定:
+ .DEFAULT 用来重建所有无法找到对于规则的目标
+ .PRECIOUS 当出现错误时,或者需要保留生成的中间目标时可以使用
+ .INTERMEDIATE :待定:
+ .SECONDARY 它的依赖文件被作为中间过程文件对待,不会被自动删除,没有任何依赖目标的它,将所有文件作为中间过程文件,不会被删除
+ .DELETE_ON_ERROR make执行过程中,如果规则命令出错,就会删除所有已被修改的目标文件
+ .IGNORE 没有任何依赖目标时,make将忽略所有命令的执行错误,可以添加指定目标,给它指定执行命令是没有意义的
+ .LOW_RESOLUTION_TIME 其他的依赖文件为低分辨率时间戳文件
+ .SILENT 如果没有任何依赖,表示不不打印执行的命令,如果加了目标则是指定目标,与make -s相同,给它加执行命令没有意义
+ .EXPORT_ALL_VARIABLES 将所有的变量传递给子make,与单独使用export效果一样
+ .NOTPARALLEL 无论是否添加-j参数,所有命令都按照串行方式执行,子make进程除外,忽略所有依赖

* 条件判断
  - ifeq ...else...endif
  #+BEGIN_SRC 
  ifeq(a,b)
      command
  else
      command
  endif
  #+END_SRC
  - ifneq
  - ifdef
  - ifndef

* 变量的定义方式

+ 展开式变量
  #+BEGIN_SRC 
  one = $(two)
  two = $(three)
  three = yes  
  
  那么$(one) 结果是 yes
  #+END_SRC
  可以看到这种变量定义方式,可以使用后面定义的变量,它的展开不是在定义时,因此可以实现对后续变量的引用

+ 直接展开式变量
  #+BEGIN_SRC 
  one := a
  two := $(one) b
  one :=c
  那么$(two) 为 a b;$(one) 为 c;
  #+END_SRC
  可以看到这种变量是直接展开的,因此不能引用后续变量

+ ?=操作符
  只有在变量没有被定义时才会被赋值
+ +=为一个变量添加值,有三点需要注意
  1) 如果之前未定义,那么将会转换为 = 并赋值
  2) 如果变量是使用:=定义的那么操作符会先展开,然后在进行:=追加
     #+BEGIN_SRC 
     var := value
     var += value1
     追加过程等价于
     var := $(var) value1
     #+END_SRC
  3) 如果变量使用=进行定义的,正常情况下跟上面一样,但是对于有变量引用的情况下那么不会进行变量展开,而是直接添加
     #+BEGIN_SRC 
     var = $(var2)
     var += value2
     追加过程等价于
     var = $(var2) value2
     #+END_SRC
     其中var2不会被展开
  
+ 变量的替换($var:.o=.c)所有.o被替换为.c与函数$(patsubst a,b $(var))一样

+ 目标指定变量
  #+BEGIN_SRC 
  traget:var=value1 var2 = value2
  #+END_SRC
  - 目标指定变量会扩展到目标的所有依赖规则上去
  - 可以多目标
+ 模式指定变量
  #+BEGIN_SRC 
  %.o %.obj:CFLAGS += -O
  #+END_SRC

+ overrid 变量的覆写,多用来覆写命令行指定的变量值
  - 一般情况下,命令行指定的变量将覆盖makefile中指定的变量,其实命令行指定的变量也是加上overrid声明的
  - 对于以 overrid定义的变量 如果要对其追加或者修改值,同样需要加上overrid,否则修改不会生效

* 进阶规则

+ 非.开头的第一个读取到的非模式规则被视为最终规则
+ ;和规则在一行时,可以直接接命令,如果没有,就是空命令
+ $有特殊含义,需要用$$
+ 依赖有两种,一种是正常的另一种是在"|"之后的
  #+BEGIN_SRC 
    libes=libone.a
    foo:foo.c | $(libes)
    $(CC) $(CFLAGS) $< -o $@ $(libes)
  #+END_SRC
  libes的更新不会引起foo目标的重建
+ 除了规则中与命令中外,不能直接使用通配符,而要使用$(wildcar x)来代替
  如:
  #+BEGIN_SRC 
    objects = $(wildcar *.o)
  #+END_SRC
  代表所有.o文件,放到规则中时会被展开

* make程序的行为与参数
+ -n 只显示所有执行的命令,并不会真正执行
+ -s 禁止所有命令的显示,命令行可以使用@来禁止命令回显,也可以关闭-w选项
+ -j 可以并行执行的命令数量
+ -k 与-i不同,它是用来忽略make本身遇到错误的,非毁灭性错误
+ -I 指定makefile的文件搜索目录
+ -i 忽略所有命令执行过程中的错误
+ -C 执行make前进入一个目录,并设置CURDIR工作目录变量
+ -t 更新所有目标时间戳,而不执行任何规则
+ -e 使用系统环境变量覆盖makefile中的同名变量定义
+ -w 通常会自动打开,用来打印进出目录的情况
+ -f 指定要编译makefile
+ -t 更新文件时间戳
+ -q 如果文件为最新,返回0
+ -W 以当前时间作为指定文件的时间戳,可以配合其他参数来检查哪些目标依赖此文件
+ -p 命令执行前,打印出make读取的makefile的所有数据
+ -v 允许输出makefile被执行的过程信息
+ -o 用来指定文件不需要重建
+ -B 强制重建所有目标文件
+ -d 打印出所有调试信息
+ -r 取消所有隐含规则
+ -R 取消所有内嵌的隐含变量
+ -S 取消 -k选项
+ 对于规则中的命令,如果有多个命令,并使用换行分割,那么make将多个命令视为彼此独立的,互不影响,甚至cd命令都没用,如果想要作为一条命令,可以使用;分割,并使用\换行

* 注意事项
  1) makefile中的文件搜索路径,与gcc这些编译器的搜索路径并不是公用的,所以可能需要分别指定
  2) 为了使编译器的文件路径与make程序找到的那些依赖或需要生成的目标文件路径保持一直,可以使用自动化变量
  3) .h头文件在make中是用来确定是否需要重新构建目标的,在gcc等构建程序中实际不需要明确指定.h文件,因为源文件中以及includel了
  4) 大部分时候makefile中的每个目标代表一个文件
  5) 一个目标如果依赖于另一个没有规则和命令的目标时,该目标总会被认为是最新的,所以前者的命令肯定会执行
  6) 双冒号规则和冒号规则的区别
     - 如果两者都没有依赖,只有命令,那么双冒号会无条件执行,而冒号只有在目标不存在时执行
     - 如果同一个文件作为多个双冒号目标时,会被单独处理,而不是整合,也就是只执行,此依赖定义的命令,而单冒号会整合所有依赖,但是只能有一个有构建命令
  7) 除非显示指明变量传递,否则make不会自动传递变量,出现重复时,以当前文件所定义的为准
  8) 一旦使用export或者unexport其作用将会在子make链中一直存在,除非显式取消
  9) 如果不希望变量MAKEFLAGS自动传递给子make可以:
     #+BEGIN_SRC 
     all:
       cd subdir && $(MAKE) MAKEFLAGS=
     #+END_SRC
     将其赋空
  10) target:; 空命令 用来屏蔽不希望看到的某些隐含规则
  11) 当引用一个没有定义的变量时,make默认它为空

* 例子
1) 获得当前所有的c文件,并自动替换为o后辍
   #+BEGIN_SRC 
      objects:=$(patsubst %.c,%.o,$(wildcard *.c))
      one:$(objects)
          cc -o one $(objects)
   #+END_SRC

2) GPATH,与VPATH以及目标重建问题
   #+BEGIN_SRC 
       libes=one.a
       GPATH=src
       vpath=src
       .........
       one.a:...
           .......
   #+END_SRC
   如果工作目录和src目录都不存在目标one.a,那么会在工作目录下重建,否则就在GPATH指定目录下重建

3) 一个make创建多个程序,并可以搜索多个目录下的makefile并执行
    #+BEGIN_SRC 
    SUBDIRS=one two three
    all:prog1 prog2 prog3
    .PHONY:all
    .PHONY:other $(SUBDIRS)
    prog1:prog1.o libxxx.o
    gcc ...........
    prog2:prog2.o libxxx.o
    gcc ...........
    prog3:prgo3.o libxxx.o
    gcc ...........
    
    other:$(SUBDIRS)
    $(SUBDIRS):
        $(make) -C $@
    one:two              #<----------------限定执行顺序,必须在two执行完之后才能执行
    
    #+END_SRC

4) 一个简便的依赖关系,大型项目推荐使用
    #+BEGIN_SRC 
    objs= one.o two.o
    one.o:one.h 
    two.o:two.h three.h
    $(objs):four.h
    #+END_SRC
5) 有用的模式规则
   #+BEGIN_SRC 
   files=one.elc two.o three.o
   $(fillter %.o,$(files)):%.o:%.c
       $(CC) -c $(CFLAGS) $< -o $@
   $(fillter %.elc,(files)):%.elc:%.el
       emacs -f batch-byte-compile $<
   #另一个小例子
   onefile twofile:%file:.o
        echo -$* > $@
   #+END_SRC
6) 自动产生依赖
    #+BEGIN_SRC 
    gcc -M one.c
    gcc -MM one.c #<----------不会将标准头文件列出来,也就是使用<>包含的文件
    
    #另一个例子 产生诸如 one.o one.d:one.c one.h的规则
    %.d:%.c
        $(CC) -M $(CPPFLAGS) $< > $@.$$$$;\
        sed 's,\($*\)\.o[ :]*,\1.o %@ : ,g' < $@.$$$$ >$@;\
        rm -f $@.$$$$
        
    #+END_SRC
7) make库文件搜索路径替换为gcc使用的库文件路径
   #+BEGIN_SRC 
   VPATH = src:../includes
   override CFLAGS +=$(patsubst %,-I%,$(subst :, ,$(VPATH)))
   #+END_SRC
8) 利用隐含规则的例子
   #+BEGIN_SRC 
   cur_dir = $(shell pwd)
   incs := $(cur_dir)/include
   CFLAGS := -Wall -I$(incs)
   exef := one two
   .PHONY : all clean
   all : $(exef)
   one: CFLAGS+=-O2
   two:CGLAGS+= -g
   
   clean:
   $(RM) *.o *.d $(EXES)
   #+END_SRC


[[file:./make.html]]
